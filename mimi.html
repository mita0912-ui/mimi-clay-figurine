<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mimi — Shiny Moldable Clay</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;700;900&display=swap" rel="stylesheet">
<style>
  :root{
    --bg: #C7FF00;            /* chartreuse background */
    --navy: #07122B;          /* dark navy text / model base */
    --panel: rgba(7,18,43,0.06);
    --muted: rgba(7,18,43,0.7);
    --accent: #07122B;
    --space-2:8px; --space-3:16px; --space-4:24px;
    font-family:"Orbitron", system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:var(--bg);
    color:var(--navy);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    overflow:hidden;
  }
  header{
    position:fixed;left:0;right:0;top:0;z-index:40;
    display:flex;align-items:center;justify-content:space-between;
    padding:12px 18px;background:linear-gradient(180deg, rgba(255,255,255,0.06), transparent);
    backdrop-filter: blur(4px);
  }
  .brand{font-weight:900;letter-spacing:0.06em;color:var(--navy);font-size:18px}
  nav{display:flex;gap:12px;align-items:center}
  nav a{color:var(--navy);opacity:.85;text-decoration:none;font-weight:600}
  .btn{border:2px solid rgba(7,18,43,0.12);padding:8px 12px;border-radius:10px;background:transparent;color:var(--navy);cursor:pointer;font-weight:700}
  .btn.primary{background:var(--navy);color:var(--bg);border-color:transparent}
  main{display:flex;flex-direction:column;gap:12px;padding:80px 18px 18px 18px;height:100vh}
  .stage{flex:1;display:flex;gap:18px;flex-direction:column}
  .canvas-wrap{
    flex:1;border-radius:14px;overflow:hidden;display:block;background:linear-gradient(180deg, rgba(7,18,43,0.06), rgba(7,18,43,0.03));
    box-shadow: 0 18px 40px rgba(7,18,43,0.12);position:relative;
  }
  canvas{width:100%;height:100%;display:block;touch-action:none}
  .hud{
    position:absolute;left:14px;top:14px;background:rgba(255,255,255,0.02);padding:8px 10px;border-radius:10px;font-family:monospace;font-size:13px;color:var(--navy)
  }
  .controls{
    display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:12px;justify-content:flex-start;
  }
  .control{background:rgba(255,255,255,0.04);padding:10px;border-radius:10px;min-width:170px}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input[type=range]{width:100%}
  input[type=color]{width:48px;height:36px;border-radius:8px;border:none;cursor:pointer}
  footer{position:fixed;left:18px;right:18px;bottom:18px;display:flex;justify-content:space-between;align-items:center;color:var(--navy);font-size:13px}
  #cursor{position:fixed;left:0;top:0;width:18px;height:18px;border-radius:50%;pointer-events:none;background:var(--navy);mix-blend-mode:multiply;transform:translate(-50%,-50%);transition:transform .1s ease,opacity .15s}
  .sr-only{position:absolute!important;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden}
  @media(min-width:980px){
    main{padding:100px 40px 40px 40px}
    .stage{flex-direction:row}
    .canvas-wrap{flex:1;min-height:72vh}
    .sidebar{width:360px}
  }
  button:focus,input:focus{outline:3px solid rgba(7,18,43,0.12);outline-offset:3px}
</style>
</head>
<body>
  <header>
    <div class="brand" aria-hidden="true">Mimi</div>
    <nav aria-label="Main">
      <a href="#play">Playground</a>
      <a href="#about">About</a>
      <button class="btn" id="resetFocusBtn" title="Reset (R)">Reset</button>
      <button class="btn primary" id="snapBtn">Snapshot</button>
    </nav>
  </header>

  <main>
    <section class="stage" aria-label="Playground region">
      <div class="canvas-wrap" id="canvasWrap" role="region" aria-label="Interactive moldable sculpture">
        <canvas id="threeCanvas" aria-describedby="canvasDesc"></canvas>
        <div class="hud" id="hud">Mode: Mold • Space = pause • R = reset</div>
        <div class="sr-only" id="canvasDesc">Interactive shiny dark sculpture. Drag to mold, pinch to scale, use stylus pressure for stronger pulls. Press Space to pause animation.</div>
      </div>

      <aside class="sidebar" aria-label="Controls">
        <h3 style="margin:0 0 10px 0;color:var(--navy);font-weight:800">Controls</h3>

        <div class="controls" role="group" aria-label="Playground controls">

          <div class="control">
            <label for="stiff">Stiffness (spring)</label>
            <input id="stiff" type="range" min="0.01" max="1.2" step="0.01" value="0.18" />
            <div id="stiffVal" style="font-size:13px;color:var(--muted);margin-top:6px">0.18</div>
          </div>

          <div class="control">
            <label for="damp">Damping (viscosity)</label>
            <input id="damp" type="range" min="0.85" max="0.999" step="0.001" value="0.92" />
            <div id="dampVal" style="font-size:13px;color:var(--muted);margin-top:6px">0.92</div>
          </div>

          <div class="control">
            <label for="radius">Influence Radius</label>
            <input id="radius" type="range" min="0.02" max="0.6" step="0.01" value="0.22" />
            <div id="radiusVal" style="font-size:13px;color:var(--muted);margin-top:6px">0.22</div>
          </div>

          <div class="control">
            <label for="noise">Noise Amplitude</label>
            <input id="noise" type="range" min="0" max="0.8" step="0.01" value="0.14" />
            <div id="noiseVal" style="font-size:13px;color:var(--muted);margin-top:6px">0.14</div>
          </div>

          <div class="control">
            <label for="metal">Shininess (metalness)</label>
            <input id="metal" type="range" min="0" max="1" step="0.01" value="0.9" />
            <div id="metalVal" style="font-size:13px;color:var(--muted);margin-top:6px">0.90</div>
          </div>

          <div class="control" style="display:flex;gap:8px;align-items:center;">
            <label for="colorPick" style="flex:1">Base Color</label>
            <input id="colorPick" type="color" value="#07122B" aria-label="Base color" />
          </div>

        </div>

        <div style="margin-top:12px;display:flex;gap:8px">
          <button class="btn" id="pauseBtn" aria-pressed="false">Pause</button>
          <button class="btn" id="resetBtn">Reset</button>
        </div>

        <p style="margin-top:12px;color:var(--muted);font-size:13px">Interactions: drag to pull/push. Pinch to scale. Stylus pressure increases pull strength. Reduced-motion respected.</p>
      </aside>
    </section>
  </main>

  <footer>
    <div style="font-weight:700">Mimi — Shiny Clay</div>
    <div style="opacity:.8">© <span id="year"></span></div>
  </footer>

  <div id="cursor" aria-hidden="true"></div>

  <script type="module">
  // ====== Globals & UI bindings ======
  document.getElementById('year').textContent = new Date().getFullYear();
  const canvas = document.getElementById('threeCanvas');
  const canvasWrap = document.getElementById('canvasWrap');
  const hud = document.getElementById('hud');
  const cursor = document.getElementById('cursor');

  // UI elements
  const ui = {
    stiff: document.getElementById('stiff'),
    damp: document.getElementById('damp'),
    radius: document.getElementById('radius'),
    noise: document.getElementById('noise'),
    metal: document.getElementById('metal'),
    colorPick: document.getElementById('colorPick'),
    stiffVal: document.getElementById('stiffVal'),
    dampVal: document.getElementById('dampVal'),
    radiusVal: document.getElementById('radiusVal'),
    noiseVal: document.getElementById('noiseVal'),
    metalVal: document.getElementById('metalVal'),
    pauseBtn: document.getElementById('pauseBtn'),
    resetBtn: document.getElementById('resetBtn'),
    resetFocusBtn: document.getElementById('resetFocusBtn'),
    snapBtn: document.getElementById('snapBtn'),
  };

  // reflect values
  const reflect = () => {
    ui.stiffVal.textContent = Number(ui.stiff.value).toFixed(2);
    ui.dampVal.textContent = Number(ui.damp.value).toFixed(3);
    ui.radiusVal.textContent = Number(ui.radius.value).toFixed(2);
    ui.noiseVal.textContent = Number(ui.noise.value).toFixed(2);
    ui.metalVal.textContent = Number(ui.metal.value).toFixed(2);
  };
  reflect();

  // reduced motion
  const reduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
  if(reduced) {
    hud.textContent = 'Reduced motion — limited animation';
  }

  // pointer cursor visual (hide on touch devices)
  if(!matchMedia('(pointer: coarse)').matches){
    document.addEventListener('mousemove', e => {
      cursor.style.left = (e.clientX) + 'px';
      cursor.style.top = (e.clientY) + 'px';
    });
  } else cursor.style.display = 'none';

  // ====== Fast noise (compact) ======
  class FastNoise {
    constructor(seed=1337){
      this.p = new Uint8Array(512);
      let perm = new Uint8Array(256);
      for(let i=0;i<256;i++) perm[i]=i;
      let s = seed|0;
      for(let i=255;i>0;i--){
        s = (s*1664525 + 1013904223)|0;
        let r = (s >>> 0) % (i+1);
        let tmp = perm[i]; perm[i]=perm[r]; perm[r]=tmp;
      }
      for(let i=0;i<512;i++) this.p[i]=perm[i & 255];
    }
    fade(t){ return t*t*t*(t*(t*6 - 15) + 10); }
    lerp(a,b,t){ return a + t*(b-a); }
    grad(hash,x,y,z){
      const h = hash & 15;
      const u = h < 8 ? x : y;
      const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
      return ((h&1)? -u : u) + ((h&2)? -v : v);
    }
    noise3(x,y,z){
      const p=this.p;
      const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
      x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
      const u = this.fade(x), v = this.fade(y), w = this.fade(z);
      const A = p[X] + Y, AA = p[A] + Z, AB = p[A+1] + Z;
      const B = p[X+1] + Y, BA = p[B] + Z, BB = p[B+1] + Z;
      return this.lerp(
        this.lerp(
          this.lerp(this.grad(p[AA], x, y, z), this.grad(p[BA], x-1, y, z), u),
          this.lerp(this.grad(p[AB], x, y-1, z), this.grad(p[BB], x-1, y-1, z), u),
        v),
        this.lerp(
          this.lerp(this.grad(p[AA+1], x, y, z-1), this.grad(p[BA+1], x-1, y, z-1), u),
          this.lerp(this.grad(p[AB+1], x, y-1, z-1), this.grad(p[BB+1], x-1, y-1, z-1), u),
        v),
      w);
    }
  }

  // ====== Three.js scene + soft-body physics ======
  (async function run(){
    // capability guard: if very low concurrency, show simplified fallback
    const lowPower = navigator.hardwareConcurrency && navigator.hardwareConcurrency < 3;

    try {
      const THREE = await import('https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js');
      const { Scene, PerspectiveCamera, WebGLRenderer, AmbientLight, DirectionalLight,
              Mesh, IcosahedronGeometry, MeshStandardMaterial, Vector2, Raycaster, Color, PMREMGenerator, EquirectangularReflectionMapping, TextureLoader } = THREE;

      const renderer = new WebGLRenderer({canvas, antialias:true, alpha:true});
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(canvas.clientWidth || innerWidth, canvas.clientHeight || innerHeight);

      const scene = new Scene();
      // camera
      const camera = new PerspectiveCamera(50, 2, 0.1, 100);
      camera.position.z = 3.6;

      // lights
      const dir = new DirectionalLight(0xffffff, 1.0);
      dir.position.set(5,5,5); scene.add(dir);
      scene.add(new AmbientLight(0xffffff, 0.45));

      // environment: create a simple procedural sky-like texture for nicer reflections
      // We'll create a tiny canvas gradient and use it as an env map via PMREM
      const envCanvas = document.createElement('canvas');
      envCanvas.width = 256; envCanvas.height = 128;
      const ctx = envCanvas.getContext('2d');
      const g = ctx.createLinearGradient(0,0,envCanvas.width,envCanvas.height);
      g.addColorStop(0, '#ffffff'); g.addColorStop(0.5, '#c7ff00'); g.addColorStop(1, '#07122b');
      ctx.fillStyle = g; ctx.fillRect(0,0,envCanvas.width,envCanvas.height);
      const envTex = new THREE.CanvasTexture(envCanvas);
      envTex.mapping = EquirectangularReflectionMapping;
      const pmrem = new PMREMGenerator(renderer);
      const envMap = pmrem.fromEquirectangular(envTex).texture;
      scene.environment = envMap;

      // geometry + shiny material
      const detail = 4; // moderate vertex count for interactivity
      const geometry = new IcosahedronGeometry(1.0, detail);
      const baseColor = new Color(ui.colorPick.value || '#07122B');
      const material = new MeshStandardMaterial({
        color: baseColor,
        metalness: parseFloat(ui.metal.value),
        roughness: 0.18,
        envMap: envMap,
        envMapIntensity: 1.0,
        clearcoat: 0.2,
        clearcoatRoughness: 0.05,
      });

      const mesh = new Mesh(geometry, material);
      scene.add(mesh);

      // Copy vertex arrays
      const posAttr = geometry.attributes.position;
      const vertexCount = posAttr.count;
      const rest = new Float32Array(posAttr.array); // rest positions
      const curr = new Float32Array(posAttr.array); // current positions
      const vel = new Float32Array(vertexCount * 3); // velocities
      // small per-vertex stiffness variation to feel organic
      const stiffnessVariation = new Float32Array(vertexCount);
      for(let i=0;i<vertexCount;i++) stiffnessVariation[i] = 0.85 + Math.random() * 0.5; // multiplier

      // noise instance
      const fastNoise = new FastNoise(Math.floor(Math.random()*65535));

      // raycaster & pointer
      const ray = new Raycaster();
      const pointer = new Vector2();
      let pointerWorld = null;
      let pointerState = {down:false,pressure:0,screenX:0,screenY:0};

      // multi-touch scale
      let pinch = { active:false, startDist:0, startScale:1, currentScale:1 };
      mesh.scale.set(1,1,1);

      // physics params controlled by UI
      let stiffness = parseFloat(ui.stiff.value);
      let damping = parseFloat(ui.damp.value);
      let influence = parseFloat(ui.radius.value);
      let noiseAmp = parseFloat(ui.noise.value);
      let metalVal = parseFloat(ui.metal.value);

      // UI update listeners
      ui.stiff.addEventListener('input', e => { stiffness = parseFloat(e.target.value); reflect(); });
      ui.damp.addEventListener('input', e => { damping = parseFloat(e.target.value); reflect(); });
      ui.radius.addEventListener('input', e => { influence = parseFloat(e.target.value); reflect(); });
      ui.noise.addEventListener('input', e => { noiseAmp = parseFloat(e.target.value); reflect(); });
      ui.metal.addEventListener('input', e => { metalVal = parseFloat(e.target.value); material.metalness = metalVal; reflect(); });
      ui.colorPick.addEventListener('input', e => { material.color.set(e.target.value); });

      // reflect current values visually
      function reflect(){
        ui.stiffVal.textContent = stiffness.toFixed(2);
        ui.dampVal.textContent = damping.toFixed(3);
        ui.radiusVal.textContent = influence.toFixed(2);
        ui.noiseVal.textContent = noiseAmp.toFixed(2);
        ui.metalVal.textContent = material.metalness.toFixed(2);
      }
      reflect();

      // reset to rest positions
      function resetShape(){
        for(let i=0;i<rest.length;i++){
          curr[i] = rest[i] + (Math.random()-0.5)*0.0001;
          posAttr.array[i] = curr[i];
          vel[i] = 0;
        }
        posAttr.needsUpdate = true;
      }

      // initial slight jitter for expressiveness
      for(let i=0;i<rest.length;i++){
        rest[i] += (Math.random()-0.5) * 0.008;
        curr[i] = rest[i];
      }

      resetShape();

      // pause toggle
      let paused = false;
      function togglePause(){
        paused = !paused;
        ui.pauseBtn.textContent = paused ? 'Resume' : 'Pause';
        ui.pauseBtn.setAttribute('aria-pressed', String(paused));
        hud.textContent = paused ? 'Paused' : 'Mode: Mold • Space = pause • R = reset';
      }
      ui.pauseBtn.addEventListener('click', togglePause);
      ui.resetBtn.addEventListener('click', resetShape);
      document.getElementById('resetFocusBtn').addEventListener('click', resetShape);

      // snapshot
      ui.snapBtn.addEventListener('click', () => {
        renderer.domElement.toBlob(blob => {
          if(!blob) return;
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = 'mimi_shiny_clay.png';
          document.body.appendChild(a); a.click(); a.remove();
          URL.revokeObjectURL(url);
        });
      });

      // keyboard controls
      window.addEventListener('keydown', (e) => {
        if(e.code === 'Space'){ e.preventDefault(); togglePause(); }
        if(e.code === 'KeyR'){ resetShape(); }
      });

      // input handling: pointer & touch
      function updatePointerFromEvent(e){
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        pointerState.screenX = clientX; pointerState.screenY = clientY;
        pointerState.pressure = e.pressure !== undefined ? e.pressure : (e.force || 0.5);
      }

      canvasWrap.addEventListener('pointerdown', (e) => {
        canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
        pointerState.down = true;
        updatePointerFromEvent(e);
      }, {passive:true});
      window.addEventListener('pointerup', (e) => {
        pointerState.down = false;
      }, {passive:true});
      canvasWrap.addEventListener('pointermove', (e) => {
        updatePointerFromEvent(e);
        if(!('touches' in e)) {
          cursor.style.left = e.clientX + 'px'; cursor.style.top = e.clientY + 'px';
        }
      }, {passive:true});

      // pinch handlers for touch scale
      let ongoingTouches = [];
      function getTouchById(id){ return ongoingTouches.find(t => t.id === id); }
      canvasWrap.addEventListener('touchstart', (ev) => {
        for(const t of ev.changedTouches) ongoingTouches.push({id:t.identifier, x:t.clientX, y:t.clientY});
        if(ongoingTouches.length === 2){
          pinch.active = true;
          const a = ongoingTouches[0], b = ongoingTouches[1];
          pinch.startDist = Math.hypot(a.x - b.x, a.y - b.y);
          pinch.startScale = mesh.scale.x;
        }
      }, {passive:true});
      canvasWrap.addEventListener('touchmove', (ev) => {
        for(const t of ev.changedTouches){
          const ot = getTouchById(t.identifier);
          if(ot){ ot.x = t.clientX; ot.y = t.clientY; }
        }
        if(ongoingTouches.length === 2 && pinch.active){
          const a = ongoingTouches[0], b = ongoingTouches[1];
          const d = Math.hypot(a.x - b.x, a.y - b.y);
          const factor = d / Math.max(1, pinch.startDist);
          const newScale = Math.max(0.4, Math.min(3.0, pinch.startScale * factor));
          mesh.scale.set(newScale, newScale, newScale);
        }
      }, {passive:true});
      canvasWrap.addEventListener('touchend', (ev) => {
        for(const t of ev.changedTouches){
          const idx = ongoingTouches.findIndex(o => o.id === t.identifier);
          if(idx >= 0) ongoingTouches.splice(idx,1);
        }
        if(ongoingTouches.length < 2) pinch.active = false;
      }, {passive:true});

      // animation / physics loop
      let lastTime = performance.now();
      function step(now){
        const dt = Math.min(0.033, (now - lastTime) / 1000); // clamp dt
        lastTime = now;
        if(!paused){
          // update pointer world by raycasting
          ray.setFromCamera(pointer, camera);
          const hits = ray.intersectObject(mesh, false);
          pointerWorld = hits.length ? hits[0].point : null;

          // physics: per vertex spring with noise + pointer impulse
          const time = now * 0.001;
          const invRadius = 1.0 / Math.max(0.0001, influence * 2.0); // world approx
          for(let i=0;i<vertexCount;i++){
            const idx = i*3;
            // rest pos
            const rx = rest[idx], ry = rest[idx+1], rz = rest[idx+2];
            // current pos
            let x = curr[idx], y = curr[idx+1], z = curr[idx+2];
            // velocity
            let vx = vel[idx], vy = vel[idx+1], vz = vel[idx+2];

            // spring force to rest
            const stiffLocal = stiffness * stiffnessVariation[i];
            let fx = (rx - x) * stiffLocal;
            let fy = (ry - y) * stiffLocal;
            let fz = (rz - z) * stiffLocal;

            // noise breathing
            const n = fastNoise.noise3(rx*0.9 + time*0.6, ry*0.9 + time*0.4, rz*0.9 + time*0.3);
            const nscale = noiseAmp * 0.9;
            fx += n * nscale;
            fy += n * nscale;
            fz += n * nscale * 0.6;

            // pointer influence
            if(pointerWorld){
              // approximate distance between this vertex and pointer in object space (mesh unscaled base)
              const dx = x - pointerWorld.x;
              const dy = y - pointerWorld.y;
              const dz = z - pointerWorld.z;
              const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
              const radiusWorld = influence * 2.0 * mesh.scale.x;
              if(dist < radiusWorld){
                // falloff
                const fall = (1 - (dist / radiusWorld));
                // direction (towards pointer)
                const dirx = (pointerWorld.x - x);
                const diry = (pointerWorld.y - y);
                const dirz = (pointerWorld.z - z);
                // pointer strength: bigger when pressed, scaled by pressure (0..1) and optionally movement velocity
                const pressure = pointerState.pressure || 0.5;
                const basePull = 8.5 * (pointerState.down ? 1.6 : 0.22);
                const pull = basePull * (1 + pressure * 1.5);
                fx += dirx * pull * fall * dt;
                fy += diry * pull * fall * dt;
                fz += dirz * pull * fall * dt;
              }
            }

            // integrate velocity
            vx = (vx + fx * dt);
            vy = (vy + fy * dt);
            vz = (vz + fz * dt);

            // damping
            vx *= damping;
            vy *= damping;
            vz *= damping;

            // integrate position
            x += vx * dt;
            y += vy * dt;
            z += vz * dt;

            // write back
            vel[idx] = vx; vel[idx+1] = vy; vel[idx+2] = vz;
            curr[idx] = x; curr[idx+1] = y; curr[idx+2] = z;
          }

          // commit vertex positions to geometry
          for(let i=0;i<posAttr.array.length;i++) posAttr.array[i] = curr[i];
          posAttr.needsUpdate = true;
          geometry.computeVertexNormals();
        }

        // subtle rotation for life
        mesh.rotation.y += 0.0015;
        // render
        renderer.render(scene, camera);
        requestAnimationFrame(step);
      }

      // resize helper
      function resize(){
        const rect = canvasWrap.getBoundingClientRect();
        const w = Math.max(1, Math.floor(rect.width));
        const h = Math.max(1, Math.floor(rect.height));
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        renderer.setSize(w * dpr, h * dpr, false);
        renderer.domElement.style.width = rect.width + 'px';
        renderer.domElement.style.height = rect.height + 'px';
        camera.aspect = rect.width / rect.height;
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', resize);
      resize();

      // start loop
      requestAnimationFrame(step);

      // expose some debug (if needed)
      // window.__mimi = {mesh, geometry, material, fastNoise, resetShape};

      // touch pointer pressure note: stylus pressure available as event.pressure
      canvas.addEventListener('pointerdown', e => {
        pointerState.down = true;
        pointerState.pressure = e.pressure || 0.5;
      });
      canvas.addEventListener('pointerup', e => { pointerState.down = false; });
      canvas.addEventListener('pointermove', e => {
        // update pointer coords in NDC for raycasting
        const rect = canvas.getBoundingClientRect();
        pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        pointerState.pressure = e.pressure || pointerState.pressure;
      });

    } catch(err){
      console.error('Three.js failed to initialize', err);
      // fallback static canvas drawing
      const ctx = canvas.getContext && canvas.getContext('2d');
      if(ctx){
        canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight;
        const g = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
        g.addColorStop(0,'#C7FF00'); g.addColorStop(1,'#07122B');
        ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#07122B'; ctx.font = '28px monospace';
        ctx.fillText('Interactive artwork unavailable', 20, 40);
      }
    }

  })();

  // small UX: show cursor interaction scale on actionable elements
  document.querySelectorAll('.btn,input').forEach(el=>{
    el.addEventListener('mouseenter', ()=> cursor.style.transform = 'translate(-50%,-50%) scale(2.4)');
    el.addEventListener('mouseleave', ()=> cursor.style.transform = 'translate(-50%,-50%) scale(1)');
  });

  </script>
</body>
</html>
